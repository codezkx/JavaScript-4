# 网络请求与远程资源

## 一、XMLHttpRequest 对象

### 1、XHR实例属性与方法

>**实例属性与方法**
>
>````js
>onabort: null  // 	在调用xhr.abort();终止连接时触发。 
>
>onerror: null  // 在请求出错时触发。
>onload: null  // 在成功接收完响应时触发。 无论状态码是什么，都会触发 load 事件。
>onloadend: null // 在通信完成时，且在 error、abort 或 load 之后触发。
>onloadstart: null // 在接收到响应的第一个字节时触发。	
>onprogress: null  // 	在接收响应期间反复触发。
>onreadystatechange: ƒ () // zi
>ontimeout: null // 延迟事件。超过延迟时触发
>readyState: 4 // 请求状态变化
>response: "" // 响应的数据
>responseText: "" // 响应的文本
>responseType: "" // 响应的类型
>responseURL: “” 请求url
>responseXML: null // 获取响应的XML类型
>status: 405 // 请求状态
>statusText: "Method Not Allowed" // 请求状态文本
>timeout: 0 // 请求延迟
>upload: XMLHttpRequestUpload {onloadstart: null, onprogress: null, onabort: null, onerror: null, onload: null, …} // 上传属性
>withCredentials: false
>````
>
>**原型属性与方法**
>
>````js
>DONE: 4
>HEADERS_RECEIVED: 2
>LOADING: 3
>OPENED: 1
>UNSENT: 0 // 以上状态码对应readyState
>abort: ƒ abort()
>getAllResponseHeaders: ƒ getAllResponseHeaders()
>getResponseHeader: ƒ getResponseHeader()
>onreadystatechange: (...)
>open: ƒ open()
>/*
>	假设服务器实际发送了 XML 数据，但响应头设置的 MIME 类型是 text/plain。结果就会导致虽
>然数据是 XML，但 responseXML 属性值是 null。此时调用 overrideMimeType()可以保证将响应
>  当成 XML 而不是纯文本来处理：
>  let xhr = new XMLHttpRequest(); 
>  xhr.open("get", "text.php", true); 
>  xhr.overrideMimeType("text/xml"); 
>  xhr.send(null);
>  这个例子强制让 XHR 把响应当成 XML 而不是纯文本来处理。为了正确覆盖响应的 MIME 类型，必须在调用 send()之前调用 overrideMimeType()。
>*/
>overrideMimeType: ƒ overrideMimeType() // 重写 XHR 响应的 MIME 类型
>readyState: 4
>response: ""
>responseText: ""
>responseType: ""
>responseURL: “”
>responseXML: null
>send: ƒ send()
>setRequestHeader: ƒ setRequestHeader()
>status: 405
>statusText: (...)
>timeout: (...)
>upload: XMLHttpRequestUpload
>withCredentials: false
>````
>
>

> **readystatechange事件**
>
> ​     readyState 属性变化时调用
>
> **open方法：(为发送请求做准备)**
>
> ​                    参数
>
> ​                        1、请求方法;
>
> ​                        2、请求的url;
>
> ​                        3、请求是否使用异步;
>
> ​                    注意： 只能访问同源 URL，也就是域名相同、端口相同、协议相同。如果请求的 URL 与
>
> ​                        发送请求的页面在任何方面有所不同，则会抛出安全错误
>
>  **abort方法**: 
>
> ​		取消异步请求
>
> **send方法（发送定义好的请求）**
>
> ​		参数：
>
> ​                1、请求体发送的数据；
>
> **status**：HTTP 状态码；
>
> **responseText：**响应返回的文本
>
> **responseXML：**responseXML 只能获取XML数据
>
> **readyState属性**L：
>
> ​	 0：未初始化（Uninitialized）。尚未调用 open()方法。
>
> ​                     1：已打开（Open）。已调用 open()方法，尚未调用 send()方法。
>
> ​                     2：已发送（Sent）。已调用 send()方法，尚未收到响应。
>
> ​                     3：接收中（Receiving）。已经收到部分响应。
>
> ​                     4：完成（Complete）。已经收到所有响应，可以使用了
>
> ````js
> // 创建xhr实例
> const xhr = new XMLHttpRequest();
> console.log(xhr);
> console.log(xhr.readyState, '未调用open方法')
> /* 
>   readystatechange事件
>       readyState 属性变化时调用
> */
> xhr.addEventListener('readystatechange', (e) => {
>   console.log(e, 'e');
> })
> /* 
>   1、使用open方法：(为发送请求做准备)
>       参数
>           1、请求方法;
>           2、请求的url;
>           3、请求是否使用异步;
>       注意： 只能访问同源 URL，也就是域名相同、端口相同、协议相同。如果请求的 URL 与
>           发送请求的页面在任何方面有所不同，则会抛出安全错误
> */
> xhr.open("get", "/api/getList", true);
> console.log(xhr.readyState, '调用open方法')
> 
> /* 
>   abort方法: 取消异步请求
> */
> //    xhr.abort()
> 
> /* 
>   2、使用 send方法：（发送定义好的请求）  
>       参数：
>           1、请求体发送的数据；
> 
> */
> xhr.send(null);
> console.log(xhr.status) //   
> console.log(xhr.responseText) // 响应返回的文本 
> console.log(xhr.responseXML) // responseXML 只能获取XML数据
> /* 
>   3、readyState属性
>        0：未初始化（Uninitialized）。尚未调用 open()方法。
>        1：已打开（Open）。已调用 open()方法，尚未调用 send()方法。
>        2：已发送（Sent）。已调用 send()方法，尚未收到响应。
>        3：接收中（Receiving）。已经收到部分响应。
>        4：完成（Complete）。已经收到所有响应，可以使用了
> */
> console.log(xhr.readyState, '调用open方法，且调用send方法')
> ````

### 2、HTTP头部

>> XHR 请求会发送以下头部字段
>
>````js
> Accept：浏览器可以处理的内容类型。
> Accept-Charset：浏览器可以显示的字符集。
> Accept-Encoding：浏览器可以处理的压缩编码类型。
> Accept-Language：浏览器使用的语言。
> Connection：浏览器与服务器的连接类型。
> Cookie：页面中设置的 Cookie。  Host：发送请求的页面所在的域。
> Referer：发送请求的页面的 URI。注意，这个字段在 HTTP 规范中就拼错了，所以考虑到兼容
>性也必须将错就错。（正确的拼写应该是 Referrer。）
> User-Agent：浏览器的用户代理字符串。
>````
>
>> **设置请求头 setRequestHeader(key, value)**
>
>> **获取响应头部 getResponseHeader(key)**
>
>> **所有响应头部 getAllResponseHeader()** 
>
>````js
>// 创建xhr实例
>const xhr = new XMLHttpRequest();
>/* 
>    1、使用open方法：(为发送请求做准备)
>        参数
>            1、请求方法;
>            2、请求的url;
>            3、请求是否使用异步;
>        注意： 只能访问同源 URL，也就是域名相同、端口相同、协议相同。如果请求的 URL 与
>            发送请求的页面在任何方面有所不同，则会抛出安全错误
>*/
>xhr.open("get", "/api/getList", true);
>// 设置请求 请求头信息
>xhr.setRequestHeader('MyHeader', 'MaValue');
>/* 
>    2、使用 send方法：（发送定义好的请求）  
>        参数：
>            1、请求体发送的数据；
>
>*/
>xhr.send(null);
>
>// 获取响应头部信息   
>const myHeader = xhr.getResponseHeader('MyHeader');
>console.log(myHeader, 'myHeader');
>// 获取所有响应头部信息   
>const headerAll = xhr.getAllResponseHeaders();
>console.log(headerAll, 'headerAll1')
>````

### 3、GET请求

> 1、最常用的请求方法是 GET 请求，用于向服务器查询某些信息。必要时，需要在 GET 请求的 URL后面添加查询字符串参数。
>
> 2、发送 GET 请求最常见的一个错误是查询字符串格式不对。查询字符串中的每个名和值都必须使用encodeURIComponent()编码，所有名/值对必须以和号（&）分隔。
>
> 

### 4、POST请求

> 第二个最常用的请求是 POST 请求，用于向服务器发送应该保存的数据。每个 POST 请求都应该在请求体中携带提交的数据，而 GET 请求则不然。POST 请求的请求体可以包含非常多的数据，而且数据可以是任意格式。 
>
> **注意：表单发送POST请求时**
>
> > POST 请求与提交表单是不一样的。服务器逻辑需要读取原始 POST数据才能取得浏览器发送的数据。不过，可以使用 XHR 模拟表单提交。为此，第一步需要把 ContentType 头部设置为"application/x-www-formurlencoded"，这是提交表单时使用的内容类型。第二步是创建对应格式的字符串。

### 5、XMLHttpRequest Level 2 

#### **FormData 类型**

> **FormData 类型**
>
> >现代 Web 应用程序中经常需要对表单数据进行序列化，因此 XMLHttpRequest Level 2 新增了
> >
> >FormData 类型。FormData 类型便于表单序列化，也便于创建与表单类似格式的数据然后通过 XHR发送。
>
> >1. **append**: *ƒ append()* // 添加一条数据
> >
> >   >**参数**
> >   >
> >   >```
> >   >name
> >   >```
> >   >
> >   >`value` 中包含的数据对应的表单名称。
> >   >
> >   >```
> >   >value
> >   >```
> >   >
> >   >`表单的值。`可以是[`USVString`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String) 或 [`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob) (包括子类型，如 [`File`](https://developer.mozilla.org/zh-CN/docs/Web/API/File))。
> >   >
> >   >`filename` 可选
> >   >
> >   >传给服务器的文件名称 (一个 [`USVString`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String)), 当一个 [`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob) 或 [`File`](https://developer.mozilla.org/zh-CN/docs/Web/API/File) 被作为第二个参数的时候， [`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob) 对象的默认文件名是 "blob"。 [`File`](https://developer.mozilla.org/zh-CN/docs/Web/API/File) 对象的默认文件名是该文件的名称。
> >   >
> >   >````js
> >   >// 示例
> >   >formData.append(name, value);
> >   >formData.append(name, value, filename);
> >   >````
> >   >
> >   >
> >
> >2. **delete**: *ƒ delete() *// 删除对应数据
> >
> >> **[`FormData`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData) 接口的 `delete()` 方法会从 `FormData` 对象中删除指定键，即 key，和它对应的值，即 value。**
> >>
> >> **语法**
> >>
> >> ````
> >> formData.delete(name);
> >> ````
> >>
> >> >### [参数](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/delete#参数)
> >> >
> >> >- `name`
> >> >
> >> >  要删除的键（Key）的名字。
> >
> >1. **entries**: *ƒ entries()* // 格式化数据格式 
> >
> >> The **`FormData.entries()`** 方法返回一个 [`iterator`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols)对象，此对象可以遍历访问 FormData 中的键值对。其中键值对的 key 是一个 [`USVString`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String) 对象；value 是一个 [`USVString`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String) , 或者 [`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)对象。
> >>
> >> **无参数**
> >>
> >> ```
> >> // Create a test FormData object
> >> var formData = new FormData();
> >> formData.append('key1', 'value1');
> >> formData.append('key2', 'value2');
> >> 
> >> // Display the key/value pairs
> >> for(var pair of formData.entries()) {
> >>    console.log(pair[0]+ ', '+ pair[1]);
> >> }
> >> ```
> >>
> >> 
> >
> >1. **forEach**: *ƒ forEach()* //遍历formDate
> >
> >
> >
> >1. **get**: *ƒ ()* // 获取一条数据
> >
> >>[`FormData`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData) 的 `get()` 方法用于返回 FormData 对象中和指定的键关联的第一个值，如果你想要返回和指定键关联的全部值，那么可以使用 [`getAll()`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/getAll) 方法。
> >>
> >>### [参数](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/get#参数)
> >>
> >>- `name`
> >>
> >>  将要获取值的键名。
> >>
> >>````js
> >>formData.append('username', 'Chris');
> >>formData.append('username', 'Bob');
> >>
> >>formData.get('username'); // Returns "Chris"
> >>````
> >
> >1. **getAll**: *ƒ getAll()* // 获取数据数据
> >
> >> **`getAll()`** 方法会返回该 [`FormData`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData) 对象指定 key 的所有值。
> >>
> >> ### [参数](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/getAll#参数)
> >>
> >> - `name`
> >>
> >>   一个 [`USVString`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String) 表示要检索的 key 名称。
> >>
> >> ### [返回](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/getAll#返回)
> >>
> >> 一个 [`FormDataEntryValue` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/FormData) 数组。
> >>
> >> ````js
> >> // 示例
> >> formData.append('username', 'Chris');
> >> formData.append('username', 'Bob');
> >> 
> >> formData.getAll('username'); // Returns ["Chris", "Bob"]
> >> ````
> >
> >1. **has**: *ƒ has()*
> >
> >>**`has()`**方法会返回一个布尔值，表示该[`FormData`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData)对象是否含有某个 key。
> >>
> >>### [参数](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/has#参数)
> >>
> >>- `name`
> >>
> >>  一个 [`USVString`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String) ，要查询的 key 名称。
> >>
> >>### [返回](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/has#返回)
> >>
> >>一个 [`Boolean` (en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean)。
> >>
> >>````
> >>// 示例
> >>formData.has('username'); // Returns false
> >>formData.append('username', 'Chris');
> >>formData.has('username'); // Returns true
> >>````
> >>
> >>
> >
> >1. **keys**: *ƒ keys()*
> >
> >> **`FormData.keys()`** 该方法返回一个迭代器（[`iterator`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols)），遍历了该 formData 包含的所有 key，这些 key 是 [`USVString`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String) 对象。
> >>
> >> **无参数**
> >>
> >> #### [返回值](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/keys#返回值)
> >>
> >> 返回一个迭代器（ [`iterator`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols)）。
> >>
> >> ````js
> >> // 示例
> >> // 先创建一个 FormData 对象
> >> var formData = new FormData();
> >> formData.append('key1', 'value1');
> >> formData.append('key2', 'value2');
> >> 
> >> // 输出所有的 key
> >> for (var key of formData.keys()) {
> >>    console.log(key);
> >> }
> >> ````
> >
> >1. **set**: *ƒ ()*
> >
> >> **`set()`** 方法会对 `FormData` 对象里的某个 `key` 设置一个新的值，如果该 `key` 不存在，则在最后添加。
> >>
> >> #### 参数
> >>
> >> - `name`
> >>
> >>   字段名称。
> >>
> >> - `value`
> >>
> >>   字段的值，该值可以是一个 [`USVString`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String) 或 [`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)（包括其子类，例如 [`File`](https://developer.mozilla.org/zh-CN/docs/Web/API/File)），如果不是这两个指定的类型，其将被转成一个字符串。
> >>
> >> - `filename` 可选
> >>
> >>   当第二个参数传递的是一个 blob 对象（[`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)）或者 file 对象（[`File`](https://developer.mozilla.org/zh-CN/docs/Web/API/File)），filename 参数就代表传给服务端的文件名（一个 [`USVString`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String)）。 [`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob) 对象的默认文件名是 "blob"，[`File`](https://developer.mozilla.org/zh-CN/docs/Web/API/File) 对象的默认文件名则为其“name”属性
> >>
> >> **备注：** 如果对 FormData 对象插入一个 blob 对象（ [`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)），那么发送给服务器的请求头部（header）
> >>
> >> `````js
> >> // test:
> >> formData.set('username', 'Chris');
> >> formData.set('userpic', myFileInput.files[0], 'chris.jpg');
> >> `````
> >
> >1. **values**: *ƒ values()*
> >
> >> **`FormData.values()`** 方法返回一个允许遍历该对象中所有值的 [`迭代器`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols) 。这些值是 [`USVString`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String) 或是[`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob) 对象。
> >>
> >> **无参数**
> >>
> >> ### [返回值](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/values#返回值)
> >>
> >> 返回一个[`迭代器`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols).
> >>
> >> ````js
> >> //创建一个 FormData 测试对象
> >> var formData = new FormData();
> >> formData.append('key1', 'value1');
> >> formData.append('key2', 'value2');
> >> 
> >> //显示值
> >> for (var value of formData.values()) {
> >>    console.log(value);
> >> }
> >> ````

## 二、进度事件

>  loadstart：在接收到响应的第一个字节时触发。
>
>  progress：在接收响应期间反复触发。
>
>  error：在请求出错时触发。
>
>  abort：在调用 abort()终止连接时触发。
>
>  load：在成功接收完响应时触发。
>
>  loadend：在通信完成时，且在 error、abort 或 load 之后触发。
>
> > 每次请求都会首先触发 loadstart 事件，之后是一个或多个 progress 事件，接着是 error、abort或 load 中的一个，最后以 loadend 事件结束。

### 1、load 事件

> load 事件在响应接收完成后立即触发，这样就不用检查 readyState 属性了。onload 事件处理程序会收到一个 event 对象，其 target 属性设置为 XHR 实例，在这个实例上可以访问所有 XHR 对象属性和方法。
>
> **注意**：并不是所有浏览器都实现了这个事件的 event 对象，考虑到跨浏览器兼容。
>
> ````js
> /* 
>      loadstart：在接收到响应的第一个字节时触发。
>      progress：在接收响应期间反复触发。
>      error：在请求出错时触发。
>      abort：在调用 abort()终止连接时触发。
>      load：在成功接收完响应时触发。 无论状态码是什么，都会触发 load 事件。
>      loadend：在通信完成时，且在 error、abort 或 load 之后触发。
> */
> 
> const xhr = new XMLHttpRequest();
> xhr.onabort = function(e) {
>     console.log(e) //  不同浏览器可能没有实现Event
>     console.log(xhr.status);
> }
> xhr.open("get", "altevents.php", true);
> xhr.onload = function(e) {
>     console.log(e) //  不同浏览器可能没有实现Event
>     console.log(xhr.status);
> }
> xhr.send(null);
> // xhr.abort(); // 取消请求
> ````
>
> 无论状态码是什么，都会触发 load 事件。这意味着还需要检查 status属性才能确定数据是否有效。

### 2、progress事件

>在浏览器接收数据期间，这个事件会反复触发。每次触发时，onprogress 事件处理程序都会收到 event 对象.
>
>````js
>progress：在接收响应期间反复触发。
>  包含 3 个额外属性(三个参数可以表示请求进度)
>      lengthComputable: 是一个布尔值，表示进度信息是否可用；
>      loaded: 是接收到的字节数
>      totalSize: 是响应的 ContentLength 头部定义的总字节数。
>
>  const xhr = new XMLHttpRequest();
>  xhr.onabort = function(e) {
>      console.log(e, 'onabort'); //  不同浏览器可能没有实现Event
>  }
>
>  xhr.open("get", "altevents.php", true);
>  xhr.onload = function(e) {
>      console.log(e, 'onload'); //  不同浏览器可能没有实现Event
>      console.log(xhr.status);
>  }
>  xhr.onprogress = function(event) {
>      console.log(event, 'onprogress');
>  }
>  xhr.send(null);      
>````
>
>>在前面的例子中，每次触发 progress 事件都会更新 HTML 元素中的信息。假设响应有 Content-Length 头部，就可利用这些信息计算出已经收到响应的百分比。

## 三、跨源资源共享

#### CORS跨域

CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。

整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。

因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。

##### 两种请求

浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。

只要同时满足以下两大条件，就属于简单请求。

> （1) 请求方法是以下三种方法之一：
>
> - HEAD
> - GET
> - POST
>
> （2）HTTP的头信息不超出以下几种字段：
>
> - Accept
> - Accept-Language
> - Content-Language
> - Last-Event-ID
> - Content-Type：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。

凡是不同时满足上面两个条件，就属于非简单请求。

浏览器对这两种请求的处理，是不一样的。

##### 简单请求

 **基本流程**

对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个`Origin`字段。

下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个`Origin`字段。

> ```http
> GET /cors HTTP/1.1
> Origin: http://api.bob.com
> Host: api.alice.com
> Accept-Language: en-US
> Connection: keep-alive
> User-Agent: Mozilla/5.0...
> ```

上面的头信息中，`Origin`字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。

如果`Origin`指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含`Access-Control-Allow-Origin`字段（详见下文），就知道出错了，从而抛出一个错误，被`XMLHttpRequest`的`onerror`回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。

如果`Origin`指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。

> ```http
> Access-Control-Allow-Origin: http://api.bob.com
> Access-Control-Allow-Credentials: true
> Access-Control-Expose-Headers: FooBar
> Content-Type: text/html; charset=utf-8
> ```

上面的头信息之中，有三个与CORS请求相关的字段，都以`Access-Control-`开头。

**（1）Access-Control-Allow-Origin**

该字段是必须的。它的值要么是请求时`Origin`字段的值，要么是一个`*`，表示接受任意域名的请求。

**（2）Access-Control-Allow-Credentials**

该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为`true`，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为`true`，如果服务器不要浏览器发送Cookie，删除该字段即可。

**（3）Access-Control-Expose-Headers**

该字段可选。CORS请求时，`XMLHttpRequest`对象的`getResponseHeader()`方法只能拿到6个基本字段：`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`。如果想拿到其他字段，就必须在`Access-Control-Expose-Headers`里面指定。上面的例子指定，`getResponseHeader('FooBar')`可以返回`FooBar`字段的值。

 **withCredentials 属性**

上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定`Access-Control-Allow-Credentials`字段。

> ```http
> Access-Control-Allow-Credentials: true
> ```

另一方面，开发者必须在AJAX请求中打开`withCredentials`属性。

> ```javascript
> var xhr = new XMLHttpRequest();
> xhr.withCredentials = true;
> ```

否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。

但是，如果省略`withCredentials`设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭`withCredentials`。

> ```javascript
> xhr.withCredentials = false;
> ```

需要注意的是，如果要发送Cookie，`Access-Control-Allow-Origin`就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的`document.cookie`也无法读取服务器域名下的Cookie。

#### 非简单请求

##### **预检请求**

非简单请求是那种对服务器有特殊要求的请求，比如请求方法是`PUT`或`DELETE`，或者`Content-Type`字段的类型是`application/json`。

非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。

浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。

下面是一段浏览器的JavaScript脚本。

> ```javascript
> var url = 'http://api.alice.com/cors';
> var xhr = new XMLHttpRequest();
> xhr.open('PUT', url, true);
> xhr.setRequestHeader('X-Custom-Header', 'value');
> xhr.send();
> ```

上面代码中，HTTP请求的方法是`PUT`，并且发送一个自定义头信息`X-Custom-Header`。

浏览器发现，这是一个非简单请求，就自动发出一个"预检"请求，要求服务器确认可以这样请求。下面是这个"预检"请求的HTTP头信息。

> ```http
> OPTIONS /cors HTTP/1.1
> Origin: http://api.bob.com
> Access-Control-Request-Method: PUT
> Access-Control-Request-Headers: X-Custom-Header
> Host: api.alice.com
> Accept-Language: en-US
> Connection: keep-alive
> User-Agent: Mozilla/5.0...
> ```

"预检"请求用的请求方法是`OPTIONS`，表示这个请求是用来询问的。头信息里面，关键字段是`Origin`，表示请求来自哪个源。

除了`Origin`字段，"预检"请求的头信息包括两个特殊字段。

**（1）Access-Control-Request-Method**

该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是`PUT`。

**（2）Access-Control-Request-Headers**

该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是`X-Custom-Header`。

 **预检请求的回应**

服务器收到"预检"请求以后，检查了`Origin`、`Access-Control-Request-Method`和`Access-Control-Request-Headers`字段以后，确认允许跨源请求，就可以做出回应。

> ```http
> HTTP/1.1 200 OK
> Date: Mon, 01 Dec 2008 01:15:39 GMT
> Server: Apache/2.0.61 (Unix)
> Access-Control-Allow-Origin: http://api.bob.com
> Access-Control-Allow-Methods: GET, POST, PUT
> Access-Control-Allow-Headers: X-Custom-Header
> Content-Type: text/html; charset=utf-8
> Content-Encoding: gzip
> Content-Length: 0
> Keep-Alive: timeout=2, max=100
> Connection: Keep-Alive
> Content-Type: text/plain
> ```

上面的HTTP回应中，关键的是`Access-Control-Allow-Origin`字段，表示`http://api.bob.com`可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。

> ```http
> Access-Control-Allow-Origin: *
> ```

如果服务器否定了"预检"请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被`XMLHttpRequest`对象的`onerror`回调函数捕获。控制台会打印出如下的报错信息。

> ```bash
> XMLHttpRequest cannot load http://api.alice.com.
> Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
> ```

服务器回应的其他CORS相关字段如下。

> ```http
> Access-Control-Allow-Methods: GET, POST, PUT
> Access-Control-Allow-Headers: X-Custom-Header
> Access-Control-Allow-Credentials: true
> Access-Control-Max-Age: 1728000
> ```





**（1）Access-Control-Allow-Methods**

该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求。

**（2）Access-Control-Allow-Headers**

如果浏览器请求包括`Access-Control-Request-Headers`字段，则`Access-Control-Allow-Headers`字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。

**（3）Access-Control-Allow-Credentials**

该字段与简单请求时的含义相同。

**（4）Access-Control-Max-Age**

该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。

**Node 原生http实现**

```js
  //设置允许跨域的域名，*代表允许任意域名跨域
  res.setheader("Access-Control-Allow-Origin", "*");
  //允许的header类型
  res.setHeader('Access-Control-Allow-Headers', 'x-requested-with,Authorization,token, content-type');
  //跨域允许的请求方式
  res.header("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS,PATCH");
  //可选，用来指定本次预检请求的有效期，单位为秒。在此期间，不用发出另一条预检请求。
  res.header('Access-Control-Max-Age', 1728000);//预请求缓存20天
```



**浏览器的正常请求和回应**

一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个`Origin`头信息字段。服务器的回应，也都会有一个`Access-Control-Allow-Origin`头信息字段。

下面是"预检"请求之后，浏览器的正常CORS请求。

> ```http
> PUT /cors HTTP/1.1
> Origin: http://api.bob.com
> Host: api.alice.com
> X-Custom-Header: value
> Accept-Language: en-US
> Connection: keep-alive
> User-Agent: Mozilla/5.0...
> ```

上面头信息的`Origin`字段是浏览器自动添加的。

下面是服务器正常的回应。

> ```http
> Access-Control-Allow-Origin: http://api.bob.com
> Content-Type: text/html; charset=utf-8
> ```

上面头信息中，`Access-Control-Allow-Origin`字段是每次回应都必定包含的。

#### w3c规定不容许设置的 请求头字段有

> `Accept-Charset`
> `Accept-Encoding`
> `Access-Control-Request-Headers`
> `Access-Control-Request-Method`
> `Connection`
> `Content-Length`
> `Cookie`
> `Cookie2`
> `Date`
> `DNT`
> `Expect`
> `Host`
> `Keep-Alive`
> `Origin`
> `Referer`
> `TE`
> `Trailer`
> `Transfer-Encoding`
> `Upgrade`
> `Via`

## 四、Fetch API











































