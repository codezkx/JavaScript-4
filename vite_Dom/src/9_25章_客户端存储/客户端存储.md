# 客户端存储

## cookie

一、限制

>使用cookie规则
>
>1. 不超过300个cookie
>
>2. 每个cookie不超过4M
>
>3. 每个域不超过20个cookie
>
>4. 每个域不超过81 920 字节。
>
>   > 每个域能设置的 cookie 总数也是受限的，但不同浏览器的限制不同。例如：
>   >
>   >  最新版 IE 和 Edge 限制每个域不超过 50 个 cookie； 
>   >
>   >  最新版 Firefox 限制每个域不超过 150 个 cookie； 
>   >
>   >  最新版 Opera 限制每个域不超过 180 个 cookie； 
>   >
>   >  Safari 和 Chrome 对每个域的 cookie 数没有硬性限制。
>   >
>   > 如果 cookie 总数超过了单个域的上限，浏览器就会删除之前
>   >
>   > 
>   >
>   > ！！**注意：**如果 cookie 总数超过了单个域的上限，浏览器就会删除之前设置的 cookie。IE 和 Opera 会按照最近
>   >
>   > 最少使用（LRU，Least Recently Used）原则删除之前的 cookie，以便为新设置的 cookie 腾出空间。Firefox
>   >
>   > 好像会随机删除之前的 cookie.

二、cookie 的构成

>cookie 在浏览器中是由以下参数构成的
>
>>** 名称**( **name**)：唯一标识 cookie 的名称。cookie 名不区分大小写，因此 myCookie 和 MyCookie 是同一
>>
>>个名称。不过，实践中最好将 cookie 名当成区分大小写来对待，因为一些服务器软件可能这样
>>
>>对待它们。cookie 名必须经过 URL 编码。
>>
>>** 值**：存储在 cookie 里的字符串值。这个值必须经过 URL 编码。
>>
>>** 域**( **domain**)：cookie 有效的域。发送到这个域的所有请求都会包含对应的 cookie。这个值可能包含子域（如
>>
>>www.wrox.com），也可以不包含（如.wrox.com 表示对 wrox.com 的所有子域都有效）。如果不明
>>
>>确设置，则默认为设置 cookie 的域。
>>
>>** 路径**(path)：请求 URL 中包含这个路径才会把 cookie 发送到服务器。例如，可以指定 cookie 只能由
>>
>>http://www.wrox.com/books/访问，因此访问 http://www.wrox.com/下的页面就不会发送 cookie，即
>>
>>使请求的是同一个域。
>>
>>** 过期时间**(**expires**)：表示何时删除 cookie 的时间戳（即什么时间之后就不发送到服务器了）。默认情况下，
>>
>>浏览器会话结束后会删除所有 cookie。不过，也可以设置删除 cookie 的时间。这个值是 GMT 格
>>
>>式（Wdy, DD-Mon-YYYY HH:MM:SS GMT），用于指定删除 cookie 的具体时间。这样即使关闭
>>
>>浏览器 cookie 也会保留在用户机器上。把过期时间设置为过去的时间会立即删除 cookie。 
>>
>>** 安全标志**(secure)：设置之后，只在使用 SSL 安全连接的情况下才会把 cookie 发送到服务器。例如，请
>>
>>求 https://www.wrox.com 会发送 cookie，而请求 http://www.wrox.com 则不会。

三、JavaScript中的cookie

> JavaScript 中处理 cookie 比较麻烦，因为接口过于简单，只有 BOM 的 document.cookie 属性。
>
> 根据用法不同，该属性的表现迥异。要使用该属性获取值时，document.cookie 返回包含页面中所有
>
> 有效 cookie 的字符串（根据域、路径、过期时间和安全设置），以分号分隔.
>
> **注意：**所有名和值都是 URL 编码的，因此必须使用 decodeURIComponent()解码与encodeURIComponent()编码。
>
> `````js
> class CookieUtil {
> static get(name) {
>     let cookieName = `${encodeURIComponent(name)}=`,
>         cookieStart = document.cookie.indexOf(cookieName),
>         cookieValue = null;
>     if (cookieStart > -1) {
>         let cookieEnd = document.cookie.indexOf(';', cookieStart);
>         if (cookieEnd === -1) {
>             cookieEnd = document.cookie.length;
>         }
>         cookieValue = decodeURIComponent(docuemnt.cookie.substring(
>             cookieStart + cookieName.length, cookieEnd));
>         return cookieValue;
>     }
> }
> 
> static set(name, value, expires, path, domain, secure) {
>     let cookieText =
>         `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;
>     if (expires instanceof Date) {
>         cookieText += `; expires=${expires}`; 
>     }
>     if (path) {
>         cookieText += `; path=${path}`;
>     }
>     if (domain) {
>         cookieText += `; domian=${domain}`;
>     }
>     if (secure) {
>         cookieText += `; secure=${secure}`;
>     }
>     document.cookie = cookieText;
> }
> 
> static remove(name, path, domian, secure) {
>     CookieUtil.set(name, '', new Date(0), path, domian, secure);
> }
> }
> `````
>
> **子cookie**
>
> >为绕过浏览器对每个域 cookie 数的限制，有些开发者提出了子 cookie 的概念。子 cookie 是在单个
>
> >cookie 存储的小块数据，本质上是使用 cookie 的值在单个 cookie 中存储多个名/值对。最常用的子 cookie
>
> >模式如下
>
> >````js
> >name=name1=value1&name2=value2&name3=value3&name4=value4&name5=value5
> >````
>
> >
> >
> >**注意**： 不要在 cookie 中存储重要或敏感的信息。cookie 数据不是保存在安全的环境中，因
> >
> >此任何人都可能获得。应该避免把信用卡号或个人地址等信息保存在 cookie 中。

## Storage类型

>Storage 类型用于保存名/值对数据，直至存储空间上限（由浏览器决定）。Storage 的实例与其他
>
>对象一样，但增加了以下方法
>
>````
> clear()：删除所有值；不在 Firefox 中实现。
> getItem(name)：取得给定 name 的值。
> key(index)：取得给定数值位置的名称。
> removeItem(name)：删除给定 name 的名/值对。
> setItem(name, value)：设置给定 name 的值。
>Storage 有两个类型存储方式： 会话存储（SessionStorage）、持久化存储（localStorage）
>````
>
>>**Storage 类型只能存储字符串。非字符串数据在存储之前会自动转换为字符串。注意，这种转换不能在获取数据时撤销.**

### 一、sessionStorage 对象

> **sessionStorage 对象只存储会话数据，这意味着数据只会存储到浏览器关闭。这跟浏览器关闭时会消失的会话 cookie 类似。存储在 sessionStorage 中的数据不受页面刷新影响，可以在浏览器崩溃并重启后恢复。**（取决于浏览器，Firefox 和 WebKit 支持，IE 不支持。）
>
> ````js
> // 写入会话存储   
> sessionStorage.setItem('name', '张三');
> // key-> book   value -> 李四  clearSelection
> sessionStorage.book = '李四';
> 
> // 读取会话存储
> console.log(sessionStorage.getItem('name'), 'name');
> console.timeLog(sessionStorage.book, 'book');
> 
> // 获取会话长度
> console.log(sessionStorage.length, ' length');
> 
> // 读取key
> console.log(sessionStorage.key(0), 'key'); // name
> 
> // 修改会话存储
> sessionStorage.setItem('name', '张三1');
> console.log(sessionStorage.getItem('name'), 'name'); // 张三1 name
> 
> // 删除会话储存
> delete sessionStorage.name;
> console.log(sessionStorage.getItem('name'), 'name'); // null name
> 
> // sessionStorage.removeItem('book')
> // console.log(sessionStorage.book, 'book')
> 
> // 删除所有sessionStorage
> sessionStorage.clear();
> ````

### 二、localStorage 对象

>localStorage 对象取代了 globalStorage，作为在客户端持久存储数据的机制。要访问同一个 localStorage 对象，页面必须来自同一个**域（子域不可以）**、在**相同的端口**上使用**相同的协议**。
>
>````js
>// 使用方法存储数据
>localStorage.setItem("name", "Nicholas"); 
>localStorage.setItem("name1", "Nicholas1"); 
>
>// 使用属性存储数据
>localStorage.book = "Professional JavaScript"; 
>// 使用方法取得数据
>let name = localStorage.getItem("name"); 
>// 使用属性取得数据
>let book = localStorage.book;
>
>// 删除local item
>localStorage.removeItem('name')
>
>// 清除所有的localstorage
>localStorage.clear()
>````

>**两种存储方法的区别在于，存储在 localStorage 中的数据会保留到通过 JavaScript 删除或者用户清除浏览器缓存。localStorage 数据不受页面刷新影响，也不会因关闭窗口、标签页或重新启动浏览器而丢失。**

### 三、存储事件

> **每当 Storage 对象发生变化时，都会在文档上触发 storage 事件。使用属性或 setItem()设置值、使用 delete 或 removeItem()删除值，以及每次调用 clear()时都会触发这个事件**
>
>  domain：存储变化对应的域。
>
>  key：被设置或删除的键。
>
>  newValue：键被设置的新值，若键被删除则为 null。 
>
>  oldValue：键变化之前的值。
>
> ````
> window.addEventListener("storage", 
>  (event) => alert('Storage changed for ${event.domain}')); 
> 
> ````
>
> 对于 sessionStorage 和 localStorage 上的任何更改都会触发 storage 事件，但 storage 事
> 件不会区分这两者

### 四、限制

>Web Storage 也有限制。具体的限制取决于特定的浏览器。一般来说，客户端数据的大小限制是按照**每个源（协议、域和端口）**来设置的，因此每个源有固定大小的数据存储空间。分析存储数据的页面的源可以加强这一限制。





















