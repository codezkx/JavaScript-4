<!DOCTYPE html> 
<html> 
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>03_合成与影子DOM槽位</title> 
        <style> 
        </style>
    </head> 
    <body>
        <div>世纪虎</div>
        <div>影子DOM更节点</div>
        <script>
            /* 
                以下是可以容纳影子 DOM 的元素。
                 任何以有效名称创建的自定义元素（参见 HTML 规范中相关的定义）
                 <article>
                 <aside>
                 <blockquote>
                 <body>
                 <div>
                 <footer>
                 <h1>
                 <h2>
                 <h3>
                 <h4>
                 <h5>
                 <h6>
                 <header>
                 <main>
                 <nav>
                 <p>
                 <section>
                 <span>

                影子 DOM 是通过 attachShadow()方法创建并添加给有效 HTML 元素的。容纳影子 DOM 的元素
                    被称为影子宿主（shadow host）。影子 DOM 的根节点被称为影子根（shadow root）。
                创建影子DOM方法：
                    attachShadow()
                
                注意： attachShadow()方法需要一个shadowRootInit 对象，返回影子DOM的实例。shadowRootInit
                    对象必须包含一个 mode 属性，值为"open"或"closed"。对"open"影子 DOM的引用可以通过 shadowRoot
                    属性在 HTML 元素上获得，而对"closed"影子 DOM 的引用无法这样获取。
            */
           const fooEl = document.querySelectorAll('div')[1]
        //    fooEl.innerHTML = `
        //         <div>
        //             <p>Foo</p>    
        //         </div>
        //     `;
            /* 
                影子 DOM 一添加到元素中，浏览器就会赋予它最高优先级，优先渲染它的内容而不是原来的文本。
                在这个例子中，由于影子 DOM 是空的，因此<div>会在 1000 毫秒后变成空的。
            */
            // setTimeout(() => {
            //     fooEl.attachShadow({mode: 'open'});
            // }, 1000);

            /* 
                需要使用<slot>标签指示浏览器在哪里放置原来的 HTML。下面的代码修改了前面的例子，让影子宿主中的文本出现在了影子 DOM 中：
            
            */
            // fooEl.attachShadow({ mode: 'open' }).innerHTML = `
            //     <div><slot></slot> </div>
            // `;

            // for (let color of ['red', 'green', 'blue']) {
            //     const divEl = document.createElement('div');
            //     divEl.innerText = `Make me ${color}`;
            //     fooEl.appendChild(divEl);
            //     divEl
            //         .attachShadow({mode: 'open'})
            //         .innerHTML = `
            //             <p><slot></slot></p> 
            //             <style> 
            //                 p { 
            //                     color: ${color}; 
            //                 } 
            //             </style>
            //         `
            // }

            /* 
                除了默认槽位，还可以使用命名槽位（named slot）实现多个投射。这是通过匹配的 slot/name 属
                    性对实现的。带有 slot="foo"属性的元素会被投射到带有 name="foo"的<slot>上.
            
            */
           fooEl.innerHTML = `
                <div>
                    <p slot="foo">Foo</p>
                    <p slot="bar">Bar</p>
                </div>
           `
            fooEl
                .querySelector('div')
                .attachShadow({mode: 'open'})
                .innerHTML = `
                    <slot name="bar"></slot> 
                    <slot name="foo"></slot>
                `;

        </script>
    </body>
</html>